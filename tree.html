<!DOCTYPE html>
<html>
<head>
  <title>Collapsible Tree Graph</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Add any custom styles here */
  </style>
</head>
<body>
  <div id="chart-container"></div>

  <script>
    const margin = { top: 20, right: 90, bottom: 30, left: 90 };
    const width = 960;
    const dx = 10;
    const dy = width / 6;

    const tree = d3.tree().nodeSize([dx, dy]);

    // Define the diagonal function
    const diagonal = d3.linkVertical()
      .x(d => d.y)
      .y(d => d.x);

    d3.csv("data.csv").then(function(data) {
      // Data preprocessing
      console.log("Raw data:", data);
      const nestedData = d3.group(data, d => d.District);
      console.log("Nested data:", nestedData);
      const root = {
        name: "Uganda",
        children: Array.from(nestedData, ([district, districtValues]) => {
          const villageData = Array.from(d3.group(districtValues, d => d.village), ([village, villageValues]) => ({
            name: village,
            children: villageValues.map(entry => ({
              name: entry.Parameter,
              ecoli: +entry.ecoli
            }))
          }));
      
          return {
            name: district,
            children: villageData.length > 0 ? villageData : null
          };
        })
      };


      const chart = () => {
        const rootHierarchy = d3.hierarchy(root);

        rootHierarchy.x0 = dy / 2;
        rootHierarchy.y0 = 0;
        rootHierarchy.descendants().forEach((d, i) => {
          d.id = i;
          d._children = d.children;
          if (d.depth > 1) {
            d.children = null;
          }
        });

        const svg = d3.create("svg")
          .attr("viewBox", [-margin.left, -margin.top, width, dx])
          .style("font", "10px sans-serif")
          .style("user-select", "none");

        const gLink = svg.append("g")
          .attr("fill", "none")
          .attr("stroke", "#555")
          .attr("stroke-opacity", 0.4)
          .attr("stroke-width", 1.5);

        const gNode = svg.append("g")
          .attr("cursor", "pointer")
          .attr("pointer-events", "all");

        function update(event, source) {
          const duration = event?.altKey ? 2500 : 250;
          const nodes = rootHierarchy.descendants().reverse();
          const links = rootHierarchy.links();

          // Compute the new tree layout.
          tree(rootHierarchy);

          // Update the nodes...
          const node = gNode.selectAll("g")
            .data(nodes, d => d.id);

          // Enter any new nodes at the parent's previous position.
          const nodeEnter = node.enter().append("g")
            .attr("transform", d => `translate(${source.y0},${source.x0})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0)
            .on("click", (event, d) => {
              if (d._children) {
                d.children = d._children;
                d._children = null;
              } else {
                d._children = d.children;
                d.children = null;
                loadChildren(d);
              }
              update(event, d);
            });

          nodeEnter.append("circle")
            .attr("r", 2.5)
            .attr("fill", d => {
              if (d.depth === 0) {
                return "#555"; // Root node
              } else if (d._children) {
                return "#555"; // Expanded node
              } else {
                return "#999"; // Collapsed node
              }
            })
            .attr("stroke-width", 10)
            .style("pointer-events", d => {
              if (d.depth === 0) {
                return "auto"; // Enable pointer events for root node
              } else {
                return "none"; // Disable pointer events for other nodes
              }
            });

          nodeEnter.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => d._children ? -6 : 6)
            .attr("text-anchor", d => d._children ? "end" : "start")
            .text(d => d.data.name)
            .style("fill", d => {
              if (d.depth === 0) {
                return "#000"; // Root node
              } else if (d._children) {
                return "#000"; // Expanded node
              } else {
                return "#999"; // Collapsed node
              }
            })
            .style("pointer-events", d => {
              if (d.depth === 0) {
                return "auto"; // Enable pointer events for root node
              } else {
                return "none"; // Disable pointer events for other nodes
              }
            })
            .clone(true).lower()
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 3)
            .attr("stroke", "white");

          // Transition nodes to their new position.
          const nodeUpdate = node.merge(nodeEnter).transition()
            .duration(duration)
            .attr("transform", d => `translate(${d.y},${d.x})`)
            .attr("fill-opacity", 1)
            .attr("stroke-opacity", 1);

          // Transition exiting nodes to the parent's new position.
          const nodeExit = node.exit().transition()
            .duration(duration)
            .remove()
            .attr("transform", d => `translate(${source.y},${source.x})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0);

          // Update the links...
          const link = gLink.selectAll("path")
            .data(links, d => d.target.id);

          // Enter any new links at the parent's previous position.
          const linkEnter = link.enter().append("path")
            .attr("d", d => {
              const o = { x: source.x0, y: source.y0 };
              return diagonal({ source: o, target: o });
            });

          // Transition links to their new position.
          link.merge(linkEnter).transition()
            .duration(duration)
            .attr("d", diagonal);

          // Transition exiting nodes to the parent's new position.
          link.exit().transition()
            .duration(duration)
            .remove()
            .attr("d", d => {
              const o = { x: source.x, y: source.y };
              return diagonal({ source: o, target: o });
            });

          // Stash the old positions for transition.
          rootHierarchy.eachBefore(d => {
            d.x0 = d.x;
            d.y0 = d.y;
          });

          // Update the children property of each node
          rootHierarchy.each(node => {
            if (node.data.children) {
              node.children = node.data.children;
            }
          });
        }

        update(null, rootHierarchy);

        function loadChildren(node) {
          // Simulate loading children asynchronously
          setTimeout(() => {
            const childrenData = [
              { name: "Child 1" },
              { name: "Child 2" },
              { name: "Child 3" }
            ];

            node.children = childrenData.map(d => d3.hierarchy(d));
            update(null, node);
          }, 1000);
        }

        return svg.node();
      };

      const container = document.getElementById("chart-container");
      container.appendChild(chart());
    });
  </script>
</body>
</html>
