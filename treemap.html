<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Water Quality Treemap</title>
  <style>
    /* Add CSS styles here */
    .tooltip {
      position: absolute;
      background-color: white;
      border: 1px solid gray;
      border-radius: 5px;
      padding: 10px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h2>Water Quality Treemap</h2>
  
  <!-- Add the district filter -->
  <label for="district-select">Select District:</label>
  <select id="district-select"></select>
  
  <!-- Add the chart container -->
  <div id="chart"></div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Add your JavaScript code here
    d3.csv("data.csv").then(function(data) {
      // Data preprocessing and filtering

      // Nest the data by district
      const nestedData = d3.group(data, d => d.District);

      // Extract the district names
      const districts = Array.from(nestedData.keys());

      // Add district options to the select element
      const districtSelect = d3.select("#district-select");
      districtSelect.selectAll("option")
        .data(districts)
        .enter()
        .append("option")
        .attr("value", function(d) {
          return d;
        })
        .text(function(d) {
          return d;
        });

      // Chart dimensions
      const width = 1000;
      const height = 800;

      // Create a D3.js treemap layout
      const treemap = d3.treemap()
        .size([width, height])
        .padding(1);

      // Function to update the treemap based on the selected district
      function updateTreemap(selectedDistrict) {
        // Filter the data based on the selected district
        const filteredData = selectedDistrict === "all" ? data : data.filter(d => d.District === selectedDistrict);

        const root = {
          name: "Uganda",
          children: Array.from(d3.group(filteredData, d => d.District), ([district, values]) => ({
            name: district,
            children: Array.from(values, entry => ({
              name: entry.Parameter,
              village: entry.village,
              ecoli: +entry.ecoli,
              ph: +entry.pH,
              conductivity: +entry["Electrical Conductivity"],
              turbidity: +entry.turbidity
            }))
          }))
        };

        // Compute the treemap layout
        const rootHierarchy = d3.hierarchy(root)
          .sum(function(d) {
            return d.ecoli + d.ph + d.conductivity + d.turbidity;
          })
          .sort(function(a, b) {
            return b.value - a.value;
          })
          .each(function(d) {
            d.name = d.data.name; // Assign district name to each node
          });

        treemap(rootHierarchy);

        // Create the SVG container
        const svg = d3.select("#chart")
          .selectAll("svg")
          .data([null])
          .join("svg")
          .attr("viewBox", `0 0 ${width} ${height}`)
          .attr("preserveAspectRatio", "xMidYMid meet")
          .append("g")
          .attr("transform", "translate(0,0)");

        // Create the gradients for the treemap nodes
        const districtColors = d3.scaleOrdinal(d3.schemeCategory10);
        const defs = svg.append("defs");

        const gradient = defs.selectAll("linearGradient")
          .data(rootHierarchy.descendants())
          .enter()
          .append("linearGradient")
          .attr("id", function(d, i) {
            return "gradient-" + i;
          });

        gradient.append("stop")
          .attr("offset", "0%")
          .attr("stop-color", "white");

        gradient.append("stop")
          .attr("offset", "100%")
          .attr("stop-color", function(d) {
            return districtColors(d.parent.data.name); // Assign a color based on district name
          });

        // Create the treemap nodes
        const node = svg.selectAll("g")
          .data(rootHierarchy.descendants())
          .enter()
          .append("g")
          .attr("transform", function(d) {
            return "translate(" + d.x0 + "," + d.y0 + ")";
          });

        node.append("rect")
          .attr("width", function(d) {
            return d.x1 - d.x0;
          })
          .attr("height", function(d) {
            return d.y1 - d.y0;
          })
          .attr("fill", function(d, i) {
            return "url(#gradient-" + i + ")";
          })
          .attr("stroke", "white");

        // Add tooltips to the treemap nodes
        const tooltip = d3.select("body")
          .append("div")
          .attr("class", "tooltip")
          .style("opacity", 0);

        node.append("title")
          .text(function(d) {
            return `${d.data.name}: ${d.data.village}\nE.coli: ${d.data.ecoli}\npH: ${d.data.ph}\nConductivity: ${d.data.conductivity}\nTurbidity: ${d.data.turbidity}`;
          });

        node.on("mouseover", function(d) {
            tooltip.transition()
              .duration(200)
              .style("opacity", .9);
            tooltip.html(`<b>${d.data.name}</b><br>${d.data.village}<br>E.coli: ${d.data.ecoli}<br>pH: ${d.data.ph}<br>Conductivity: ${d.data.conductivity}<br>Turbidity: ${d.data.turbidity}`)
              .style("left", (d3.event.pageX + 10) + "px")
              .style("top", (d3.event.pageY - 28) + "px");
          })
          .on("mouseout", function(d) {
            tooltip.transition()
              .duration(500)
              .style("opacity", 0);
          });
      }

      // Update the treemap when the selected district changes
      districtSelect.on("change", function() {
        const selectedDistrict = this.value;
        updateTreemap(selectedDistrict);
      });

      // Initialize the treemap
      updateTreemap("all");
    });
  </script>
</body>
</html>
